#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <iostream>
#include <cassert>
#include <cmath>
#include <string>
#include <queue>
#include <set>
#include <map>
#include <cstdlib>

using namespace std;

#define INF 1e+9
#define mp make_pair
#define pb push_back
#define fi first
#define fs first
#define se second
#define i64 long long
#define li long long
#define lint long long
#define pii pair<int, int>
#define vi vector<int>

#define forn(i, n) for (int i = 0; i < (int)n; i++)
#define fore(i, b, e) for (int i = (int)b; i <= (int)e; i++)


const int maxn = 1e5 + 5;
const int inf = 1e9;
bool placed[maxn];
int a[maxn];
int b[maxn];
int tree[maxn * 4];
int where[maxn];

/*int get(int i, int L, int R, int A, int B) {
    if (L == A && R == B)
        return tree[i];
    if (L >= B || A >= R)
        return inf;
    int m = (L + R) / 2;
    int g1 = get(i * 2, L, m, A, min(m, B));
    int g2 = get(i * 2 + 1, m, R, max(A, m), B);
    return min(g1, g2);
}*/

void upd(int i, int L, int R, int pos, bool ban) {
    if (L + 1 == R) {
        tree[i] = ban ? inf : L;
        return;
    }
    int m = (L + R) / 2;
    if (pos < m)
        upd(i * 2, L, m, pos, ban);
    else upd(i * 2 + 1, m, R, pos, ban);
    tree[i] = min(tree[i * 2], tree[i * 2 + 1]);
}

void build(int i, int L, int R) {
    if (L + 1 == R) {
        tree[i] = a[L] == 0 ? L : inf;
        return;
    }
    int m = (L + R) / 2;
    build(i * 2, L, m);
    build(i * 2 + 1, m, R);
    tree[i] = min(tree[i * 2], tree[i * 2 + 1]);
}

int main() {
#ifdef LOCAL
    freopen("inp", "r", stdin);
    //freopen("outp", "w", stdout);
#else
    // freopen(TASKNAME ".in", "r", stdin);
    // freopen(TASKNAME ".out", "w", stdout);
#endif
    int tests;
    scanf("%d", &tests);
    forn(test, tests) {
        int n;
        scanf("%d", &n);
        fore(j, 1, n)
            placed[j] = false;
        fore(i, 1, n) {
            scanf("%d", &a[i]);
            placed[a[i]] = true;
        }
        build(1, 1, n + 1);
        fore(i, 1, n)
            b[i] = a[i];
        fore(i, 1, n)
            if (!placed[i]) {
                //printf("i = %d\n", i);
                vi chain;
                int x = i;
                while (true) {
                    chain.pb(x);
                    x = a[x];
                    if (x == 0)
                        break;
                }
                /*printf("chain:\n");
                for (int x : chain)
                    printf("%d ", x);
                printf("\n");*/
                int pos;
                forn(j, chain.size() + 1) {
                    int tmp = tree[1];
                    if (tmp == inf)
                        break;
                    pos = tmp;
                    if (j == (int)chain.size())
                        break;
                    upd(1, 1, n + 1, chain[j], true);
                }
                for (int x : chain)
                    if (a[x] == 0)
                        upd(1, 1, n + 1, x, false);
                //printf("pos = %d\n", pos);
                a[pos] = i;
                upd(1, 1, n + 1, pos, true);
            }
        fore(i, 1, n) {
            where[a[i]] = i;
            b[i] = a[i];
        }
        //fore(i, 1, n)
        //    printf("where[%d] = %d\n", i, where[i]);
        int ans = 0;
        fore(i, 1, n)
            if (where[i] != i) {
                /*fore(i, 1, n)
                    printf("%d ", b[i]);
                printf("\n");
                printf("i = %d\n", i);*/
                ans++;
                where[b[i]] = where[i];
                swap(b[i], b[where[i]]);
            }
        printf("%d\n", ans);
        fore(i, 1, n)
            printf("%d ", a[i]);
        printf("\n");
    }
}
